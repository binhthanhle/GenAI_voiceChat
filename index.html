<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech -> Gemini Chatbot (ElevenLabs TTS)</title> <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f3f4f6;
            padding: 1rem; /* Reduced padding */
        }
        .app-container {
            background-color: white;
            padding: 1.5rem; /* Adjusted padding */
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 95%; /* Increased width */
            max-width: 800px; /* Increased max-width */
            text-align: center;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 4rem); /* Adjust height to fill viewport minus padding */
            max-height: 90vh; /* Limit max height */
        }
        .status-indicator {
            min-height: 1.5rem;
            margin-bottom: 0.75rem; /* Reduced margin */
            font-style: italic;
            color: #6b7280;
            font-weight: 500;
        }
         /* Chat History Container */
        #chatHistory {
            flex-grow: 1; /* Allow chat history to take available space */
            overflow-y: auto; /* Enable scrolling */
            padding: 1rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            margin-bottom: 1rem; /* Space below chat */
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Space between messages */
        }
        /* Individual Chat Message Bubbles */
        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem; /* More rounded */
            max-width: 80%; /* Limit width of bubbles */
            word-wrap: break-word; /* Break long words */
            display: flex;
            align-items: flex-start; /* Align icon with top of text */
            gap: 0.5rem;
        }
        .message-bubble.user {
            background-color: #dbeafe; /* Light blue for user */
            color: #1e40af;
            align-self: flex-end; /* Align user messages to the right */
            border-bottom-right-radius: 0.25rem; /* Slightly flatten corner */
        }
        .message-bubble.gemini {
            background-color: #e5e7eb; /* Light gray for gemini */
            color: #374151;
            align-self: flex-start; /* Align gemini messages to the left */
            border-bottom-left-radius: 0.25rem; /* Slightly flatten corner */
        }
         .message-bubble i {
            margin-top: 0.125rem; /* Align icon slightly better */
         }
         .message-bubble p {
             margin: 0; /* Remove default paragraph margin */
         }
        .session-button {
            transition: all 0.3s ease;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            min-width: 150px;
            margin-top: auto; /* Push button towards bottom if space allows */
        }
        .session-button:hover:not(:disabled) {
            transform: scale(1.05);
        }
        .session-button.active-session {
            background-color: #ef4444;
            color: white;
        }
        .session-button.active-session:hover {
            background-color: #dc2626;
        }
        .session-button.processing {
            background-color: #f59e0b;
            color: white;
            cursor: not-allowed;
        }
         .session-button.speaking {
            background-color: #3b82f6;
            color: white;
            cursor: not-allowed;
        }
        label {
            font-weight: 600;
            color: #374151;
            margin-right: 0.5rem;
            white-space: nowrap;
        }
        input[type="password"], select {
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            width: auto;
            min-width: 100px;
        }
        input[type="password"] {
             flex-grow: 1;
             max-width: 300px;
             margin-bottom: 0;
        }
        input[type="password"]:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }
        .config-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem; /* Reduced gap */
            margin-bottom: 1rem; /* Reduced margin */
            padding: 0.75rem; /* Reduced padding */
            background-color: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .config-row {
             display: flex;
             align-items: center;
             justify-content: center;
             width: 100%;
             flex-wrap: wrap;
             gap: 0.5rem 1rem;
        }
        .config-row label:not(:first-child) {
             margin-left: 1rem;
        }
        #audioPlayer {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

    </style>
</head>
<body>
    <div class="app-container">
        <h1 class="text-xl font-bold mb-3 text-gray-800">Speech -> Gemini Chatbot</h1> <div class="config-section">
             <div class="config-row">
                <label for="apiKeyInput">Gemini API Key:</label>
                <input type="password" id="apiKeyInput" placeholder="Enter your Gemini API key" class="flex-grow">
             </div>
             <div class="config-row">
                 <label for="sttLanguage">Input Language:</label>
                 <select id="sttLanguage">
                     <option value="en-US" selected>English (US)</option>
                     <option value="vi-VN">Vietnamese</option>
                 </select>
             </div>
        </div>

        <div id="status" class="status-indicator">Enter API Key and select language</div>

        <div id="chatHistory">
            <div class="message-bubble gemini"> <i class="fas fa-robot text-gray-500"></i>
                 <p>Hi there! Start a session and speak your query.</p>
             </div>
        </div>

        <button id="sessionButton" class="session-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full shadow-md mt-4">
            <i class="fas fa-play mr-2"></i> Start Session
        </button>

        <audio id="audioPlayer"></audio>
        </div>

    <script>
        // --- DOM Elements ---
        const sessionButton = document.getElementById('sessionButton');
        const statusDiv = document.getElementById('status');
        const chatHistory = document.getElementById('chatHistory'); // Changed
        // const transcriptionSection = document.getElementById('transcriptionSection'); // Removed
        // const transcriptionOutput = document.getElementById('transcriptionOutput'); // Removed
        // const geminiSection = document.getElementById('geminiSection'); // Removed
        // const geminiOutput = document.getElementById('geminiOutput'); // Removed
        // const errorOutput = document.getElementById('errorOutput'); // Removed (or keep for logging only)
        const apiKeyInput = document.getElementById('apiKeyInput'); // Gemini Key
        const sttLanguageSelect = document.getElementById('sttLanguage');
        const audioPlayer = document.getElementById('audioPlayer');

        // --- Configuration ---
        const GEMINI_MODEL = "gemini-2.0-flash";
        const SILENCE_TIMEOUT_MS = 3000; // 3 seconds

        // --- ElevenLabs Configuration ---
        const ELEVENLABS_API_KEY = "sk_c8ea1b9d4af1e1ca4418c9a714553a35fc684f2263ca8521"; // User provided key
        const ELEVENLABS_VOICE_IDS = {
            "en-US": "21m00Tcm4TlvDq8ikWAM", // English voice ID
            "vi-VN": "3VnrjnYrskPMDsapTr8X"  // Vietnamese voice ID
        };
        const ELEVENLABS_API_BASE_URL = `https://api.elevenlabs.io/v1/text-to-speech/`; // Base URL

        // --- State ---
        let isSessionActive = false;
        let isListening = false;
        let isProcessing = false;
        let isSpeaking = false;
        let recognition;
        let finalTranscript = ''; // Accumulates user query
        let currentGeminiMessageElement = null; // To stream response into a bubble
        let currentSttLang = sttLanguageSelect.value;
        let abortController = null;
        let restartTimer = null;
        let silenceTimeout = null;
        let currentAudioObjectURL = null;
        let initialStartAttempt = false;

        // --- Feature Detection ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        // --- Initialization ---
        if (!SpeechRecognition) {
            console.error("Your browser doesn't support the Web Speech Recognition API. Try Chrome or Edge.");
            updateStatus("Speech Recognition not supported by browser.");
            sessionButton.disabled = true;
            sessionButton.classList.add('opacity-50', 'cursor-not-allowed');
        } else {
            setupSpeechRecognition();
        }

        // --- Event Listeners ---
        sessionButton.addEventListener('click', toggleSession);

        sttLanguageSelect.addEventListener('change', (event) => {
            currentSttLang = event.target.value;
            console.log("STT Language changed to:", currentSttLang);
            if (isSessionActive) {
                stopRecognition(true);
            }
        });

        apiKeyInput.addEventListener('input', () => {
            // hideError(); // No error div to hide
            if (!isSessionActive) updateStatus('Ready to start session');
         });

        // Audio Player Listeners
        audioPlayer.onended = () => {
            console.log('Audio finished playing.');
            isSpeaking = false;
            isProcessing = false;
            setButtonSpeaking(false);

            if (currentAudioObjectURL) {
                URL.revokeObjectURL(currentAudioObjectURL);
                currentAudioObjectURL = null;
            }

            if (isSessionActive) {
                updateStatus("Listening...");
                startRecognition();
            }
        };

        audioPlayer.onerror = (e) => {
            console.error('Audio player error:', e);
            isSpeaking = false;
            isProcessing = false;
            setButtonSpeaking(false);

            if (currentAudioObjectURL) {
                URL.revokeObjectURL(currentAudioObjectURL);
                currentAudioObjectURL = null;
            }

            if (isSessionActive) {
                updateStatus("Audio playback error. Listening...");
                startRecognition();
            }
        };


        // --- Session Management ---
        function toggleSession() {
            if (isSessionActive) {
                endSession();
            } else {
                startSession();
            }
        }

        function startSession() {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                console.error("Gemini API Key missing.");
                updateStatus("Please enter Gemini API Key.");
                apiKeyInput.focus();
                return;
            }
             if (!ELEVENLABS_API_KEY) {
                console.error("ElevenLabs API Key is missing in the code.");
                updateStatus("Configuration error (ElevenLabs).");
                return;
            }
            if (!recognition) {
                 console.error("Speech recognition not available.");
                 updateStatus("Speech recognition not available.");
                 return;
            }

            console.log("Attempting to start session...");
            finalTranscript = '';
            // hideError();
            updateStatus("Requesting microphone access...");
            initialStartAttempt = true;
            // Clear chat history on new session start? Optional.
            // chatHistory.innerHTML = '';
            startRecognition();
        }

        function endSession() {
            console.log("Ending session...");
            isSessionActive = false;

            stopRecognition(false);
            clearTimeout(silenceTimeout);
            cancelGeminiCall();
            if (isSpeaking) {
                audioPlayer.pause();
                audioPlayer.src = '';
                 if (currentAudioObjectURL) {
                    URL.revokeObjectURL(currentAudioObjectURL);
                    currentAudioObjectURL = null;
                 }
            }

            sessionButton.innerHTML = '<i class="fas fa-play mr-2"></i> Start Session';
            sessionButton.classList.remove('active-session', 'processing', 'speaking');
            sessionButton.classList.add('bg-green-500', 'hover:bg-green-600');
            sessionButton.disabled = false;
            apiKeyInput.disabled = false;
            sttLanguageSelect.disabled = false;
            updateStatus('Session Ended. Ready to start.');
            // transcriptionSection.classList.add('hidden'); // Removed
            // geminiSection.classList.add('hidden'); // Removed
            isProcessing = false;
            isSpeaking = false;
            finalTranscript = '';
            currentGeminiMessageElement = null;
        }


        // --- Speech Recognition Control ---
        function setupSpeechRecognition() {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;

            recognition.onstart = () => {
                isListening = true;
                console.log('Recognition started with lang:', recognition.lang);

                if (initialStartAttempt) {
                    console.log("Microphone access granted, session active.");
                    isSessionActive = true;
                    initialStartAttempt = false;
                    sessionButton.innerHTML = '<i class="fas fa-stop mr-2"></i> End Session';
                    sessionButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    sessionButton.classList.add('active-session');
                    apiKeyInput.disabled = true;
                    sttLanguageSelect.disabled = true;
                }

                 if (!isProcessing && !isSpeaking) {
                    updateStatus("Listening...");
                 }
            };

            recognition.onresult = handleRecognitionResult;
            recognition.onerror = handleRecognitionError;
            recognition.onend = handleRecognitionEnd;

             recognition.onspeechend = () => {
                console.log("User stopped speaking (onspeechend).");
                clearTimeout(silenceTimeout);
             };
        }

        function startRecognition() {
            if (isListening || (!isSessionActive && !initialStartAttempt)) return;

            clearTimeout(restartTimer);
            clearTimeout(silenceTimeout);

            // Don't clear chat history here, but clear transcript buffer
            finalTranscript = '';

            restartTimer = setTimeout(() => {
                try {
                    console.log("Calling recognition.start()");
                    recognition.lang = currentSttLang;
                    recognition.start();
                } catch (e) {
                    console.error("Error in recognition.start():", e);
                    if (e.name === 'InvalidStateError') {
                        console.warn("Attempted to start recognition in invalid state.");
                        if (initialStartAttempt) {
                            initialStartAttempt = false;
                            updateStatus("Failed to start. Try again.");
                            sessionButton.disabled = false;
                        } else if (isSessionActive) {
                            endSession();
                            updateStatus("Mic error. Session ended.");
                        }
                    } else {
                         updateStatus("Could not start listening. Microphone issue?");
                         if (initialStartAttempt) {
                             initialStartAttempt = false;
                             updateStatus("Failed to start. Try again.");
                             sessionButton.disabled = false;
                         } else {
                             endSession();
                         }
                    }
                }
            }, 250);
        }

        function stopRecognition(expectRestart = false) {
            clearTimeout(restartTimer);
            clearTimeout(silenceTimeout);
            if (isListening && recognition) {
                console.log("Stopping recognition. Expect restart:", expectRestart);
                try {
                    recognition.stop();
                } catch (e) {
                    console.error("Error stopping recognition:", e);
                }
                isListening = false;
            }
             if (!expectRestart && !isProcessing && !isSpeaking && !isSessionActive) {
                 updateStatus("Stopped.");
             }
        }

         function handleRecognitionResult(event) {
            if (!isSessionActive || isProcessing || isSpeaking) return;

            clearTimeout(silenceTimeout);

            let interimForThisEvent = '';
            let hasFinalInEvent = false;

            for (let i = event.resultIndex; i < event.results.length; ++i) {
                const transcriptPart = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcriptPart.trim() + ' ';
                    hasFinalInEvent = true;
                } else {
                    interimForThisEvent += transcriptPart;
                }
            }

            // Display interim results in status or a temporary bubble? For now, just log.
            // console.log('Interim:', interimForThisEvent);

            // Set a new silence timeout if we received some transcript part
            if (finalTranscript.trim() || interimForThisEvent.trim()) {
                 silenceTimeout = setTimeout(handleSilenceTimeout, SILENCE_TIMEOUT_MS);
            }
        }

        function handleSilenceTimeout() {
             if (!isSessionActive || isProcessing || isSpeaking) return;

             if (finalTranscript.trim()) {
                 console.log(`Silence timeout (${SILENCE_TIMEOUT_MS}ms) detected.`);
                 addMessageToChat(finalTranscript, 'user'); // Add user message to chat
                 sendToGemini(finalTranscript);
             } else {
                 console.log("Silence timeout detected, but no transcript to send.");
             }
        }


        function handleRecognitionError(event) {
            isListening = false;
            clearTimeout(silenceTimeout);
            console.error('Speech recognition error:', event.error, 'Message:', event.message);
            let statusMessage = `Recognition Error: ${event.error}`;

            const wasInitialAttempt = initialStartAttempt;
            initialStartAttempt = false;

            if (event.error === 'not-allowed') {
                statusMessage = "Microphone access denied. Please allow access in browser settings.";
                if (wasInitialAttempt) {
                    updateStatus("Permission denied. Session not started.");
                    sessionButton.disabled = false;
                } else {
                    endSession();
                }
            } else if (event.error === 'no-speech') {
                 console.log("No speech detected, will restart if session active.");
                 // Restart immediately if session is active and idle
                 if(isSessionActive && !isProcessing && !isSpeaking) startRecognition();
                 return; // Exit without updating status or ending session
            } else if (event.error === 'audio-capture') {
                statusMessage = "Microphone Error. Check connection/permissions.";
                endSession();
            } else if (event.error === 'network') {
                 statusMessage = "Network error during speech recognition. Check connection.";
                 // Let onend handle restart
            } else if (event.error === 'service-not-allowed') {
                 statusMessage = "Speech recognition service denied. Check browser/OS settings.";
                 endSession();
            } else {
                 statusMessage = `Recognition Error: ${event.error}. Please try restarting the session.`;
                 // Let onend handle restart
            }

            updateStatus(statusMessage);
            if (wasInitialAttempt && event.error !== 'not-allowed') {
                 updateStatus("Failed to start microphone.");
                 sessionButton.disabled = false;
            }
        }

        function handleRecognitionEnd() {
            isListening = false;
            clearTimeout(silenceTimeout);
            console.log('Recognition ended.');
            if (isSessionActive && !isProcessing && !isSpeaking) {
                console.log("Session active & idle, attempting to restart recognition...");
                startRecognition();
            } else if (isSessionActive) {
                 console.log("Recognition ended, but session is busy (processing/speaking). Will restart after idle.");
            } else {
                 console.log("Recognition ended, session inactive.");
                 if (sessionButton.classList.contains('active-session')) {
                     endSession();
                 }
            }
        }


        // --- Gemini API Call ---
        async function sendToGemini(text) {
            clearTimeout(silenceTimeout);

            const queryText = text.trim();
            if (!queryText || isProcessing || isSpeaking) {
                console.log("Send request ignored (empty query or already busy).");
                return;
            }

            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                updateStatus("Error: Gemini API Key missing.");
                endSession();
                return;
            }

            cancelGeminiCall();
            abortController = new AbortController();

            const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:streamGenerateContent?alt=sse&key=${apiKey}`;

            console.log('Sending to Gemini:', queryText);
            isProcessing = true;
            setButtonProcessing(true, 'Gemini...');
            updateStatus('Asking Gemini...');
            // geminiSection.classList.remove('hidden'); // Removed
            // geminiOutput.textContent = '...'; // Removed
            let accumulatedGeminiResponse = ''; // Local scope for response accumulation
            finalTranscript = ''; // Clear user transcript buffer *after* capturing queryText

            // Create a placeholder message bubble for Gemini's response
            currentGeminiMessageElement = addMessageToChat("...", 'gemini');

            const payload = {
                contents: [{ role: "user", parts: [{ text: queryText }] }],
            };

            if (isListening) {
                stopRecognition(false);
                console.log("Recognition paused for Gemini call.");
            }

            try {
                const response = await fetch(geminiApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    let errorBody = 'Could not read error details.';
                     let specificError = `API Error: ${response.status} ${response.statusText}.`;
                    try {
                        errorBody = await response.text();
                        if (errorBody.trim().startsWith('{')) {
                           const errorJson = JSON.parse(errorBody);
                           errorBody = errorJson.error?.message || JSON.stringify(errorJson);
                           if (response.status === 400 && errorBody.includes("API key not valid")) {
                                specificError = "Invalid Gemini API Key.";
                           } else if (response.status === 429) {
                                specificError = "API Quota Exceeded/Rate Limited.";
                           } else { specificError += ` Details: ${errorBody}`; }
                        } else { specificError += ` Details: ${errorBody}`; }
                    } catch (parseError) { specificError += ` Details: ${errorBody}`; }
                    throw new Error(specificError);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let firstChunk = true;

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();
                    for (const line of lines) {
                         if (line.startsWith('data: ')) {
                            try {
                                const jsonData = JSON.parse(line.substring(6));
                                const textPart = jsonData?.candidates?.[0]?.content?.parts?.[0]?.text;
                                if (textPart) {
                                    if (firstChunk && currentGeminiMessageElement) {
                                        // Replace "..." with the first chunk
                                        currentGeminiMessageElement.querySelector('p').textContent = textPart;
                                        firstChunk = false;
                                    } else if (currentGeminiMessageElement) {
                                        // Append subsequent chunks
                                        currentGeminiMessageElement.querySelector('p').textContent += textPart;
                                    }
                                    accumulatedGeminiResponse += textPart; // Still accumulate full response
                                    chatHistory.scrollTop = chatHistory.scrollHeight; // Scroll as content streams
                                }
                            } catch (e) { console.warn('Error parsing SSE chunk:', e); }
                        }
                    }
                }
                 // Process final buffer if necessary
                 if (buffer.startsWith('data: ')) {
                     try {
                         const jsonData = JSON.parse(buffer.substring(6));
                         const textPart = jsonData?.candidates?.[0]?.content?.parts?.[0]?.text;
                         if (textPart && currentGeminiMessageElement) {
                             if (firstChunk) {
                                 currentGeminiMessageElement.querySelector('p').textContent = textPart;
                             } else {
                                 currentGeminiMessageElement.querySelector('p').textContent += textPart;
                             }
                             accumulatedGeminiResponse += textPart;
                             chatHistory.scrollTop = chatHistory.scrollHeight;
                         }
                     } catch (e) { console.warn('Error parsing final SSE buffer:', e); }
                 }

                 // Handle cases where Gemini might return no text content
                 if (firstChunk && currentGeminiMessageElement) { // If no text parts were received
                     currentGeminiMessageElement.querySelector('p').textContent = "(No text response)";
                 }

                console.log('Gemini Response Complete:', accumulatedGeminiResponse.substring(0,100)+"...");
                currentGeminiMessageElement = null; // Reset current message element
                speakText(accumulatedGeminiResponse || "Gemini did not reply.");

            } catch (error) {
                 if (error.name === 'AbortError') {
                    console.log('Gemini fetch aborted.');
                    updateStatus('Call cancelled.');
                    if (currentGeminiMessageElement) {
                        currentGeminiMessageElement.querySelector('p').textContent = "(Cancelled)";
                    }
                 } else {
                    console.error('Error calling Gemini API:', error);
                    updateStatus(`Gemini API Error. Check console.`);
                    if (currentGeminiMessageElement) {
                        currentGeminiMessageElement.querySelector('p').textContent = "(Error fetching response)";
                    }
                 }
                 isProcessing = false;
                 setButtonProcessing(false);
                 currentGeminiMessageElement = null;
                 if (isSessionActive && !isListening) {
                     startRecognition();
                 }
            } finally {
                abortController = null;
            }
        }

        function cancelGeminiCall() {
            if (abortController) {
                console.log("Aborting Gemini API call...");
                abortController.abort();
                abortController = null;
            }
        }

        // --- Text-to-Speech (Using ElevenLabs with Fallback) ---
        async function speakText(text) {
            const handleTTSFallback = (logMessage) => {
                console.warn(logMessage);
                isSpeaking = false;
                isProcessing = false;
                setButtonSpeaking(false);
                if (isSessionActive && !isListening) {
                    updateStatus("Listening...");
                    startRecognition();
                }
            };

            if (!ELEVENLABS_API_KEY) {
                handleTTSFallback("ElevenLabs API Key missing. Skipping TTS.");
                return;
            }
            if (!text.trim() || !isSessionActive) {
                handleTTSFallback("ElevenLabs TTS skipped (no text or session ended).");
                return;
            }

            const voiceId = ELEVENLABS_VOICE_IDS[currentSttLang] || ELEVENLABS_VOICE_IDS["en-US"];
            const elevenLabsApiUrl = ELEVENLABS_API_BASE_URL + voiceId;

            console.log(`Requesting speech from ElevenLabs (Voice ID: ${voiceId})...`);
            isSpeaking = true;
            setButtonSpeaking(true);
            updateStatus('Generating audio...'); // Keep processing true

            const payload = {
                text: text,
                model_id: "eleven_multilingual_v2",
                voice_settings: { stability: 0.5, similarity_boost: 0.75 }
            };

            try {
                const response = await fetch(elevenLabsApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'xi-api-key': ELEVENLABS_API_KEY,
                        'Accept': 'audio/mpeg'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorDetail = `ElevenLabs API Error: ${response.status} ${response.statusText}`;
                    try { const errorJson = await response.json(); errorDetail += ` - ${errorJson.detail?.message || JSON.stringify(errorJson.detail)}`; }
                    catch (e) { try { const textError = await response.text(); errorDetail += ` - ${textError}`; } catch (textE) { /* ignore */ } }
                    handleTTSFallback(`ElevenLabs API request failed: ${errorDetail}`);
                    return;
                }

                const audioBlob = await response.blob();
                if (!audioBlob || audioBlob.size === 0 || !audioBlob.type.startsWith('audio/')) {
                     handleTTSFallback(`Received invalid audio data from ElevenLabs (Type: ${audioBlob?.type}, Size: ${audioBlob?.size}). Skipping TTS.`);
                     return;
                }

                if (currentAudioObjectURL) { URL.revokeObjectURL(currentAudioObjectURL); }
                currentAudioObjectURL = URL.createObjectURL(audioBlob);
                audioPlayer.src = currentAudioObjectURL;
                updateStatus('Speaking...');
                audioPlayer.play().catch(playError => {
                    handleTTSFallback(`Error initiating audio playback: ${playError}. Skipping TTS.`);
                });

            } catch (error) {
                handleTTSFallback(`Error fetching or processing ElevenLabs audio: ${error}. Skipping TTS.`);
            }
        }


        // --- UI Updates ---
        function addMessageToChat(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message-bubble', sender); // 'user' or 'gemini'

            const icon = document.createElement('i');
            icon.classList.add('fas', sender === 'user' ? 'fa-user' : 'fa-robot');
            icon.classList.add(sender === 'user' ? 'text-blue-600' : 'text-gray-500'); // Icon colors

            const textP = document.createElement('p');
            textP.textContent = text;

            messageDiv.appendChild(icon);
            messageDiv.appendChild(textP);
            chatHistory.appendChild(messageDiv);

            // Scroll to the bottom
            chatHistory.scrollTop = chatHistory.scrollHeight;
            return messageDiv; // Return the element reference for streaming updates
        }

        function updateStatus(message) {
            statusDiv.textContent = message;
             // Keep status consistent with button state if processing/speaking
             if (isProcessing && !isSpeaking) {
                 statusDiv.textContent = "Asking Gemini...";
             } else if (isSpeaking) {
                 statusDiv.textContent = "Speaking..."; // Or "Generating audio..."
             }
        }

        // Modified showError to only log to console
        function showError(message) {
            console.error("Error occurred:", message);
        }

        function hideError() {
            // No visual error element to hide anymore
        }

        // setButtonProcessing and setButtonSpeaking remain the same
        function setButtonProcessing(processing, text = 'Processing...') {
             sessionButton.disabled = processing || isSpeaking;
             if (processing && !isSpeaking) {
                 sessionButton.classList.remove('speaking');
                 sessionButton.classList.add('processing');
                 sessionButton.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i> ${text}`;
             } else if (!processing && !isSpeaking && isSessionActive) {
                 sessionButton.classList.remove('processing', 'speaking');
                 sessionButton.innerHTML = '<i class="fas fa-stop mr-2"></i> End Session';
                 sessionButton.classList.add('active-session');
                 sessionButton.disabled = false;
             } else if (!isSessionActive) {
                 sessionButton.classList.remove('processing', 'speaking', 'active-session');
                 sessionButton.innerHTML = '<i class="fas fa-play mr-2"></i> Start Session';
                 sessionButton.classList.add('bg-green-500', 'hover:bg-green-600');
                 sessionButton.disabled = false;
             }
        }

         function setButtonSpeaking(speaking) {
             sessionButton.disabled = speaking || isProcessing;
             if (speaking) {
                 sessionButton.classList.remove('processing');
                 sessionButton.classList.add('speaking');
                 sessionButton.innerHTML = `<i class="fas fa-volume-up mr-2"></i> Speaking...`;
             } else {
                 sessionButton.classList.remove('speaking');
                 if (isProcessing) {
                     setButtonProcessing(true);
                 } else if (isSessionActive) {
                     sessionButton.innerHTML = '<i class="fas fa-stop mr-2"></i> End Session';
                     sessionButton.classList.add('active-session');
                     sessionButton.disabled = false;
                 } else {
                    sessionButton.innerHTML = '<i class="fas fa-play mr-2"></i> Start Session';
                    sessionButton.classList.add('bg-green-500', 'hover:bg-green-600');
                    sessionButton.disabled = false;
                 }
             }
        }
    </script>
</body>
</html>
