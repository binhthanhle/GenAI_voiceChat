<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech -> Gemini Chatbot (Google TTS)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f3f4f6;
            padding: 1rem;
        }
        .app-container {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 95%;
            max-width: 800px;
            text-align: center;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 4rem);
            max-height: 90vh;
        }
        .status-indicator {
            min-height: 1.5rem;
            margin-bottom: 0.75rem;
            font-style: italic;
            color: #6b7280;
            font-weight: 500;
        }
        #chatHistory {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 80%;
            word-wrap: break-word;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }
        .message-bubble.user {
            background-color: #dbeafe;
            color: #1e40af;
            align-self: flex-end;
            border-bottom-right-radius: 0.25rem;
        }
        .message-bubble.gemini {
            background-color: #e5e7eb;
            color: #374151;
            align-self: flex-start;
            border-bottom-left-radius: 0.25rem;
        }
         .message-bubble i {
            margin-top: 0.125rem;
         }
         .message-bubble p {
             margin: 0;
         }
        .action-button {
            transition: all 0.3s ease;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            min-width: 150px;
            border-radius: 9999px;
            font-weight: bold;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }
        .action-button:hover:not(:disabled) {
            transform: scale(1.05);
        }
        #sessionButton.active-session {
            background-color: #ef4444;
        }
        #sessionButton.active-session:hover {
            background-color: #dc2626;
        }
        #sessionButton:not(.active-session) {
             background-color: #22c55e;
        }
        #sessionButton:not(.active-session):hover {
             background-color: #16a34a;
        }
        #clearSessionButton {
            background-color: #6b7280;
        }
        #clearSessionButton:hover {
            background-color: #4b5563;
        }
        .session-button.processing {
            background-color: #f59e0b;
            color: white;
            cursor: not-allowed;
        }
         .session-button.speaking {
            background-color: #3b82f6;
            color: white;
            cursor: not-allowed;
        }

        label {
            font-weight: 600;
            color: #374151;
            margin-right: 0.5rem;
            white-space: nowrap;
        }
        input[type="password"], select {
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            width: auto;
            min-width: 100px;
        }
        input[type="password"] {
             flex-grow: 1;
             max-width: 300px;
             margin-bottom: 0;
        }
        input[type="password"]:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }
        .config-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .config-row {
             display: flex;
             align-items: center;
             justify-content: center;
             width: 100%;
             flex-wrap: wrap;
             gap: 0.5rem 1rem;
        }
        .config-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-grow: 1;
            justify-content: center;
        }
         .config-item label {
            margin-right: 0;
         }
         .config-item input[type="password"]{
            width: 200px;
            flex-grow: 0;
         }

        #audioPlayer {
            /* Styles to make the audio player visible */
            width: 100%; /* Make player take full width */
            margin-top: 1rem; /* Add some space above the player */
            border-radius: 0.5rem;
            background-color: #f9fafb; /* Light background for the player area */
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: auto;
            padding-top: 1rem;
        }

    </style>
</head>
<body>
    <div class="app-container">
        <h1 class="text-xl font-bold mb-3 text-gray-800">Speech -> Gemini Chatbot (Google TTS)</h1>

        <div class="config-section">
             <div class="config-row">
                <div class="config-item">
                    <label for="geminiApiKeyInput">Gemini API Key:</label>
                    <input type="password" id="geminiApiKeyInput" placeholder="Enter Gemini API key" class="">
                </div>
             </div>
             <div class="config-row">
                <div class="config-item">
                    <label for="googleTtsApiKeyInput">Google TTS API Key:</label>
                    <input type="password" id="googleTtsApiKeyInput" placeholder="Enter Google TTS API key" class="">
                </div>
             </div>
             <div class="config-row">
                 <div class="config-item">
                    <label for="sttLanguage">Input/Output Language:</label>
                    <select id="sttLanguage">
                        <option value="en-US" selected>English (US)</option>
                        <option value="vi-VN">Vietnamese</option>
                        </select>
                 </div>
                 <div class="config-item">
                    <label for="silenceTimeoutSelect">Response Time:</label>
                    <select id="silenceTimeoutSelect">
                        <option value="1000">1 Second</option>
                        <option value="2000">2 Seconds</option>
                        <option value="3000" selected>3 Seconds</option>
                    </select>
                </div>
             </div>
        </div>

        <div id="status" class="status-indicator">Enter API Keys and select language</div>

        <div id="chatHistory">
            <div class="message-bubble gemini">
                 <i class="fas fa-robot text-gray-500"></i>
                 <p>Hi there! I'll speak back using Google Text-to-Speech. Start a session and talk to me.</p>
             </div>
        </div>

        <audio id="audioPlayer" controls></audio>

        <div class="button-container">
            <button id="sessionButton" class="action-button">
                <i class="fas fa-play mr-2"></i> Start Session
            </button>
            <button id="clearSessionButton" class="action-button">
                <i class="fas fa-trash-alt mr-2"></i> Clear Session
            </button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const sessionButton = document.getElementById('sessionButton');
        const clearSessionButton = document.getElementById('clearSessionButton');
        const statusDiv = document.getElementById('status');
        const chatHistory = document.getElementById('chatHistory');
        const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
        const googleTtsApiKeyInput = document.getElementById('googleTtsApiKeyInput');
        const sttLanguageSelect = document.getElementById('sttLanguage');
        const silenceTimeoutSelect = document.getElementById('silenceTimeoutSelect');
        const audioPlayer = document.getElementById('audioPlayer');

        // --- Configuration ---
        const GEMINI_MODEL = "gemini-2.0-flash";
        let SILENCE_TIMEOUT_MS = parseInt(silenceTimeoutSelect.value);

        // --- Google Text-to-Speech Configuration ---
        const GOOGLE_TTS_API_URL = `https://texttospeech.googleapis.com/v1/text:synthesize`;

        // --- State ---
        let isSessionActive = false;
        let isListening = false;
        let isProcessing = false;
        let isSpeaking = false;
        let recognition;
        let finalTranscript = '';
        let currentGeminiMessageElement = null;
        let currentSttLang = sttLanguageSelect.value;
        let abortController = null;
        let restartTimer = null;
        let silenceTimeout = null;
        let currentAudioObjectURL = null;
        let initialStartAttempt = false;

        // --- Feature Detection ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        // --- Initialization ---
        if (!SpeechRecognition) {
            console.error("Your browser doesn't support the Web Speech Recognition API. Try Chrome or Edge.");
            updateStatus("Speech Recognition not supported by browser.");
            sessionButton.disabled = true;
            sessionButton.classList.add('opacity-50', 'cursor-not-allowed');
            clearSessionButton.disabled = true;
            clearSessionButton.classList.add('opacity-50', 'cursor-not-allowed');
        } else {
            setupSpeechRecognition();
        }

        // --- Event Listeners ---
        sessionButton.addEventListener('click', toggleSession);
        clearSessionButton.addEventListener('click', clearSession);

        sttLanguageSelect.addEventListener('change', (event) => {
            currentSttLang = event.target.value;
            console.log("STT/TTS Language changed to:", currentSttLang);
            if (isSessionActive) {
                stopRecognition(true);
            }
        });

        silenceTimeoutSelect.addEventListener('change', (event) => {
            SILENCE_TIMEOUT_MS = parseInt(event.target.value);
            console.log("Silence Timeout changed to:", SILENCE_TIMEOUT_MS);
            if (silenceTimeout) {
                clearTimeout(silenceTimeout);
                if (isListening && (finalTranscript.trim() || document.querySelector('.message-bubble.user:last-child p')?.textContent?.trim())) {
                    silenceTimeout = setTimeout(handleSilenceTimeout, SILENCE_TIMEOUT_MS);
                }
            }
        });

        geminiApiKeyInput.addEventListener('input', () => {
            if (!isSessionActive) updateStatus('Ready to start session. Enter all API keys.');
         });
        googleTtsApiKeyInput.addEventListener('input', () => {
            if (!isSessionActive) updateStatus('Ready to start session. Enter all API keys.');
        });


        audioPlayer.onended = () => {
            console.log('Audio finished playing.');
            isSpeaking = false;
            isProcessing = false; // Assuming TTS was the last part of processing
            setButtonSpeaking(false);

            if (currentAudioObjectURL) {
                URL.revokeObjectURL(currentAudioObjectURL);
                currentAudioObjectURL = null;
            }

            if (isSessionActive) {
                updateStatus("Listening...");
                startRecognition();
            }
        };

        audioPlayer.onerror = (e) => {
            console.error('Audio player error:', e);
            // Log the actual error object for more details
            console.error('Audio player error event:', e.target.error);
            isSpeaking = false;
            isProcessing = false;
            setButtonSpeaking(false);

            if (currentAudioObjectURL) {
                URL.revokeObjectURL(currentAudioObjectURL);
                currentAudioObjectURL = null;
            }
            // Provide a more specific error message in the chat
            let errorMsg = "Error playing audio.";
            if (e.target && e.target.error) {
                switch (e.target.error.code) {
                    case MediaError.MEDIA_ERR_ABORTED:
                        errorMsg = 'Audio playback aborted by user.';
                        break;
                    case MediaError.MEDIA_ERR_NETWORK:
                        errorMsg = 'A network error caused audio playback to fail.';
                        break;
                    case MediaError.MEDIA_ERR_DECODE:
                        errorMsg = 'Audio playback failed due to a decoding error.';
                        break;
                    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMsg = 'The audio format is not supported.';
                        break;
                    default:
                        errorMsg = 'An unknown error occurred during audio playback.';
                }
            }
            addMessageToChat(errorMsg, "gemini");


            if (isSessionActive) {
                updateStatus("Audio playback error. Listening...");
                startRecognition();
            }
        };


        // --- Session Management ---
        function toggleSession() {
            if (isSessionActive) {
                endSession();
            } else {
                startSession();
            }
        }

        function startSession() {
            const geminiApiKey = geminiApiKeyInput.value.trim();
            const googleTtsApiKey = googleTtsApiKeyInput.value.trim();

            if (!geminiApiKey) {
                console.error("Gemini API Key missing.");
                updateStatus("Please enter Gemini API Key.");
                geminiApiKeyInput.focus();
                return;
            }
            if (!googleTtsApiKey) {
                console.error("Google TTS API Key missing.");
                updateStatus("Please enter Google TTS API Key.");
                googleTtsApiKeyInput.focus();
                return;
            }
            if (!recognition) {
                 console.error("Speech recognition not available.");
                 updateStatus("Speech recognition not available.");
                 return;
            }

            console.log("Attempting to start session...");
            finalTranscript = '';
            updateStatus("Requesting microphone access...");
            initialStartAttempt = true;
            startRecognition();
        }

        function endSession(isClearing = false) {
            console.log("Ending session...");
            isSessionActive = false;

            stopRecognition(false);
            clearTimeout(silenceTimeout);
            cancelGeminiCall();

            if (isSpeaking || audioPlayer.src) {
                audioPlayer.pause();
                audioPlayer.src = '';
                 if (currentAudioObjectURL) {
                    URL.revokeObjectURL(currentAudioObjectURL);
                    currentAudioObjectURL = null;
                 }
            }

            sessionButton.innerHTML = '<i class="fas fa-play mr-2"></i> Start Session';
            sessionButton.classList.remove('active-session', 'processing', 'speaking');
            sessionButton.disabled = false;
            geminiApiKeyInput.disabled = false;
            googleTtsApiKeyInput.disabled = false;
            sttLanguageSelect.disabled = false;
            silenceTimeoutSelect.disabled = false;

            if (!isClearing) {
                updateStatus('Session Ended. Ready to start.');
            }

            isProcessing = false;
            isSpeaking = false;
            finalTranscript = '';
            currentGeminiMessageElement = null;
        }

        function clearSession() {
            console.log("Clearing session...");
            if (isSessionActive) {
                endSession(true);
            }
            chatHistory.innerHTML = '';
            addMessageToChat("Session cleared. Ready to start a new conversation.", "gemini");
            finalTranscript = '';
            currentGeminiMessageElement = null;
            updateStatus('Session Cleared. Ready to start.');
        }


        // --- Speech Recognition Control ---
        function setupSpeechRecognition() {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;

            recognition.onstart = () => {
                isListening = true;
                console.log('Recognition started with lang:', recognition.lang);

                if (initialStartAttempt) {
                    console.log("Microphone access granted, session active.");
                    isSessionActive = true;
                    initialStartAttempt = false;
                    sessionButton.innerHTML = '<i class="fas fa-stop mr-2"></i> End Session';
                    sessionButton.classList.add('active-session');
                    geminiApiKeyInput.disabled = true;
                    googleTtsApiKeyInput.disabled = true;
                    sttLanguageSelect.disabled = true;
                    silenceTimeoutSelect.disabled = true;
                }

                 if (!isProcessing && !isSpeaking) {
                    updateStatus("Listening...");
                 }
            };

            recognition.onresult = handleRecognitionResult;
            recognition.onerror = handleRecognitionError;
            recognition.onend = handleRecognitionEnd;

             recognition.onspeechend = () => {
                console.log("User stopped speaking (onspeechend).");
                clearTimeout(silenceTimeout);
             };
        }

        function startRecognition() {
            if (isListening || (!isSessionActive && !initialStartAttempt)) return;

            clearTimeout(restartTimer);
            clearTimeout(silenceTimeout);
            finalTranscript = '';

            restartTimer = setTimeout(() => {
                try {
                    console.log("Calling recognition.start() for language:", currentSttLang);
                    recognition.lang = currentSttLang;
                    recognition.start();
                } catch (e) {
                    console.error("Error in recognition.start():", e);
                    if (e.name === 'InvalidStateError') {
                        console.warn("Attempted to start recognition in invalid state. Might be already started or stopping.");
                        if (initialStartAttempt) {
                            initialStartAttempt = false;
                            updateStatus("Failed to start microphone. Try again.");
                            sessionButton.disabled = false;
                        } else if (isSessionActive) {
                            console.warn("Recognition couldn't start despite active session. Will attempt restart on next cycle if needed.");
                        }
                    } else {
                         updateStatus("Could not start listening. Microphone issue?");
                         if (initialStartAttempt) {
                             initialStartAttempt = false;
                             updateStatus("Failed to start. Try again.");
                             sessionButton.disabled = false;
                         } else {
                             endSession();
                         }
                    }
                }
            }, 250);
        }

        function stopRecognition(expectRestart = false) {
            clearTimeout(restartTimer);
            clearTimeout(silenceTimeout);
            if (isListening && recognition) {
                console.log("Stopping recognition. Expect restart:", expectRestart);
                try {
                    recognition.stop();
                } catch (e) {
                    console.error("Error stopping recognition:", e);
                }
                isListening = false;
            }
             if (!expectRestart && !isProcessing && !isSpeaking && !isSessionActive) {
                 updateStatus("Stopped.");
             }
        }

         function handleRecognitionResult(event) {
            if (!isSessionActive || isProcessing || isSpeaking) return;

            clearTimeout(silenceTimeout);

            let interimForThisEvent = '';
            // let hasFinalInEvent = false; // Not strictly needed with current logic

            for (let i = event.resultIndex; i < event.results.length; ++i) {
                const transcriptPart = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcriptPart.trim() + ' ';
                    // hasFinalInEvent = true;
                } else {
                    interimForThisEvent += transcriptPart;
                }
            }

            if (finalTranscript.trim() || interimForThisEvent.trim()) {
                 silenceTimeout = setTimeout(handleSilenceTimeout, SILENCE_TIMEOUT_MS);
            }
        }

        function handleSilenceTimeout() {
             if (!isSessionActive || isProcessing || isSpeaking) return;

             if (finalTranscript.trim()) {
                 console.log(`Silence timeout (${SILENCE_TIMEOUT_MS}ms) detected. Sending: "${finalTranscript.trim()}"`);
                 addMessageToChat(finalTranscript.trim(), 'user');
                 sendToGemini(finalTranscript.trim());
                 finalTranscript = '';
             } else {
                 console.log("Silence timeout detected, but no final transcript to send.");
             }
        }


        function handleRecognitionError(event) {
            isListening = false;
            clearTimeout(silenceTimeout);
            console.error('Speech recognition error:', event.error, 'Message:', event.message);
            let statusMessage = `Recognition Error: ${event.error}`;

            const wasInitialAttempt = initialStartAttempt;
            initialStartAttempt = false;

            if (event.error === 'not-allowed' || event.error === 'security') {
                statusMessage = "Microphone access denied. Please allow access in browser settings.";
                if (wasInitialAttempt) {
                    updateStatus("Permission denied. Session not started.");
                    sessionButton.disabled = false;
                } else {
                    endSession();
                }
            } else if (event.error === 'no-speech') {
                 console.log("No speech detected. Recognition will restart if session is active.");
                 // Let onend handle this
                 return;
            } else if (event.error === 'audio-capture') {
                statusMessage = "Microphone Error. Check connection/permissions.";
                endSession();
            } else if (event.error === 'network') {
                 statusMessage = "Network error during speech recognition. Check connection.";
            } else if (event.error === 'service-not-allowed') {
                 statusMessage = "Speech recognition service denied. Check browser/OS settings.";
                 endSession();
            } else {
                 statusMessage = `Recognition Error: ${event.error}. Please try restarting the session.`;
            }

            updateStatus(statusMessage);
            if (wasInitialAttempt && event.error !== 'not-allowed' && event.error !== 'security') {
                 updateStatus("Failed to start microphone. Check console.");
                 sessionButton.disabled = false;
            }
        }

        function handleRecognitionEnd() {
            isListening = false;
            clearTimeout(silenceTimeout);
            console.log('Recognition ended.');

            if (isSessionActive && !isProcessing && !isSpeaking) {
                console.log("Session active & idle, attempting to restart recognition...");
                startRecognition();
            } else if (isSessionActive) {
                 console.log("Recognition ended, but session is busy (processing/speaking). Will restart after idle.");
            } else {
                 console.log("Recognition ended, session inactive.");
            }
        }


        // --- Gemini API Call ---
        async function sendToGemini(text) {
            clearTimeout(silenceTimeout);

            const queryText = text.trim();
            if (!queryText || isProcessing || isSpeaking) {
                console.log("Send request ignored (empty query or already busy).");
                if (isSessionActive && !isListening && !isProcessing && !isSpeaking) startRecognition();
                return;
            }

            const geminiApiKey = geminiApiKeyInput.value.trim();
            if (!geminiApiKey) {
                updateStatus("Error: Gemini API Key missing.");
                addMessageToChat("Gemini API Key is missing. Cannot contact Gemini.", "gemini");
                endSession();
                return;
            }

            cancelGeminiCall();
            abortController = new AbortController();

            const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:streamGenerateContent?alt=sse&key=${geminiApiKey}`;

            console.log('Sending to Gemini:', queryText);
            isProcessing = true;
            setButtonProcessing(true, 'Gemini...');
            updateStatus('Asking Gemini...');
            let accumulatedGeminiResponse = '';
            finalTranscript = '';

            currentGeminiMessageElement = addMessageToChat("...", 'gemini');

            const payload = {
                contents: [{ role: "user", parts: [{ text: queryText }] }],
            };

            if (isListening) {
                stopRecognition(true);
                console.log("Recognition paused for Gemini call.");
            }

            try {
                const response = await fetch(geminiApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    let errorBody = 'Could not read error details.';
                    let specificError = `Gemini API Error: ${response.status} ${response.statusText}.`;
                    try {
                        const errorText = await response.text();
                        if (errorText.trim().startsWith('{')) {
                           const errorJson = JSON.parse(errorText);
                           errorBody = errorJson.error?.message || JSON.stringify(errorJson);
                           if (response.status === 400 && errorBody.includes("API key not valid")) {
                                specificError = "Invalid Gemini API Key.";
                           } else if (response.status === 429) {
                                specificError = "Gemini API Quota Exceeded/Rate Limited.";
                           } else { specificError += ` Details: ${errorBody}`; }
                        } else { specificError += ` Details: ${errorText}`; }
                    } catch (parseError) { /* Use original errorBody */ }
                    throw new Error(specificError);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let firstChunk = true;

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                         if (line.startsWith('data: ')) {
                            try {
                                const jsonData = JSON.parse(line.substring(6));
                                const textPart = jsonData?.candidates?.[0]?.content?.parts?.[0]?.text;
                                if (textPart) {
                                    if (firstChunk && currentGeminiMessageElement) {
                                        currentGeminiMessageElement.querySelector('p').textContent = textPart;
                                        firstChunk = false;
                                    } else if (currentGeminiMessageElement) {
                                        currentGeminiMessageElement.querySelector('p').textContent += textPart;
                                    }
                                    accumulatedGeminiResponse += textPart;
                                    chatHistory.scrollTop = chatHistory.scrollHeight;
                                }
                            } catch (e) { console.warn('Error parsing SSE chunk from Gemini:', e, "Line:", line); }
                        }
                    }
                }
                 if (buffer.startsWith('data: ')) {
                     try {
                         const jsonData = JSON.parse(buffer.substring(6));
                         const textPart = jsonData?.candidates?.[0]?.content?.parts?.[0]?.text;
                         if (textPart && currentGeminiMessageElement) {
                             if (firstChunk) {
                                 currentGeminiMessageElement.querySelector('p').textContent = textPart;
                             } else {
                                 currentGeminiMessageElement.querySelector('p').textContent += textPart;
                             }
                             accumulatedGeminiResponse += textPart;
                             chatHistory.scrollTop = chatHistory.scrollHeight;
                         }
                     } catch (e) { console.warn('Error parsing final SSE buffer from Gemini:', e, "Buffer:", buffer); }
                 }

                 if (firstChunk && currentGeminiMessageElement) {
                     currentGeminiMessageElement.querySelector('p').textContent = "(No text response from Gemini)";
                     accumulatedGeminiResponse = "Gemini did not provide a text response.";
                 }

                console.log('Gemini Response Complete. Length:', accumulatedGeminiResponse.length);
                currentGeminiMessageElement = null;
                speakText(accumulatedGeminiResponse || "I didn't get a response from Gemini to speak.");

            } catch (error) {
                 if (error.name === 'AbortError') {
                    console.log('Gemini fetch aborted.');
                    updateStatus('Call cancelled.');
                    if (currentGeminiMessageElement) {
                        currentGeminiMessageElement.querySelector('p').textContent = "(Cancelled by user)";
                    }
                 } else {
                    console.error('Error calling Gemini API:', error.message);
                    updateStatus(`Gemini API Error. Check console.`);
                    if (currentGeminiMessageElement) {
                        currentGeminiMessageElement.querySelector('p').textContent = `(Error: ${error.message})`;
                    }
                    addMessageToChat(`Error communicating with Gemini: ${error.message}`, "gemini");
                 }
                 isProcessing = false;
                 setButtonProcessing(false);
                 currentGeminiMessageElement = null;
                 if (isSessionActive && !isListening) {
                     startRecognition();
                 }
            } finally {
                abortController = null;
            }
        }

        function cancelGeminiCall() {
            if (abortController) {
                console.log("Aborting Gemini API call...");
                abortController.abort();
                abortController = null;
            }
        }

        // --- Text-to-Speech (Using Google Cloud TTS API) ---
        async function speakText(text) {
            const ttsApiKey = googleTtsApiKeyInput.value.trim();
            if (!ttsApiKey) {
                console.warn("Google TTS API Key missing. Skipping TTS.");
                addMessageToChat("Google TTS API Key missing, cannot generate speech.", "gemini");
                isProcessing = false;
                setButtonProcessing(false);
                if (isSessionActive && !isListening) startRecognition();
                return;
            }

            if (!text.trim() || !isSessionActive) {
                console.log("TTS skipped (no text or session ended).");
                isProcessing = false;
                setButtonProcessing(false);
                if (isSessionActive && !isListening) startRecognition();
                return;
            }

            console.log(`Requesting speech from Google TTS (Lang: ${currentSttLang}). Text: "${text.substring(0,50)}..."`);
            isSpeaking = true;
            setButtonSpeaking(true);
            updateStatus('Generating audio...');

            const payload = {
                input: { text: text },
                voice: {
                    languageCode: currentSttLang,
                    ssmlGender: 'NEUTRAL'
                },
                audioConfig: {
                    audioEncoding: 'MP3'
                }
            };

            try {
                const response = await fetch(`${GOOGLE_TTS_API_URL}?key=${ttsApiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorDetail = `Google TTS API Error: ${response.status} ${response.statusText}`;
                    try {
                        const errorJson = await response.json();
                        errorDetail += ` - ${errorJson.error?.message || JSON.stringify(errorJson.error)}`;
                    } catch (e) { /* Failed to parse error JSON */ }
                    throw new Error(errorDetail);
                }

                const responseData = await response.json();
                if (!responseData.audioContent) {
                    throw new Error("No audioContent received from Google TTS API.");
                }

                const audioBytes = Uint8Array.from(atob(responseData.audioContent), c => c.charCodeAt(0));
                const audioBlob = new Blob([audioBytes], { type: 'audio/mpeg' });

                if (currentAudioObjectURL) { URL.revokeObjectURL(currentAudioObjectURL); }
                currentAudioObjectURL = URL.createObjectURL(audioBlob);

                audioPlayer.src = currentAudioObjectURL;
                updateStatus('Speaking...');
                // It's good practice to handle the promise returned by play()
                audioPlayer.play().catch(playError => {
                    console.error("Error trying to play audio:", playError);
                    // The audioPlayer.onerror event should also catch this, but good to log here too.
                    // The onerror handler will manage UI updates and state changes.
                });


            } catch (error) {
                console.error('Error with Google TTS:', error.message);
                addMessageToChat(`Could not generate speech: ${error.message}`, "gemini");
                isSpeaking = false;
                isProcessing = false;
                setButtonSpeaking(false);
                updateStatus("Error generating audio.");
                if (isSessionActive && !isListening) {
                    startRecognition();
                }
            }
        }


        // --- UI Updates ---
        function addMessageToChat(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message-bubble', sender);

            const icon = document.createElement('i');
            icon.classList.add('fas', sender === 'user' ? 'fa-user' : 'fa-robot');
            icon.classList.add(sender === 'user' ? 'text-blue-600' : 'text-gray-500');

            const textP = document.createElement('p');
            textP.textContent = text;

            messageDiv.appendChild(icon);
            messageDiv.appendChild(textP);
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
            return messageDiv;
        }

        function updateStatus(message) {
            statusDiv.textContent = message;
        }


        function setButtonProcessing(processing, text = 'Processing...') {
             sessionButton.disabled = processing || isSpeaking;

             if (processing && !isSpeaking) {
                 sessionButton.classList.remove('speaking', 'active-session');
                 sessionButton.classList.add('processing');
                 sessionButton.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i> ${text}`;
             } else if (!processing && !isSpeaking) {
                 sessionButton.classList.remove('processing', 'speaking');
                 if (isSessionActive) {
                     sessionButton.innerHTML = '<i class="fas fa-stop mr-2"></i> End Session';
                     sessionButton.classList.add('active-session');
                 } else {
                     sessionButton.innerHTML = '<i class="fas fa-play mr-2"></i> Start Session';
                     sessionButton.classList.remove('active-session');
                 }
                 sessionButton.disabled = false;
             }
        }

         function setButtonSpeaking(speaking) {
             sessionButton.disabled = speaking || isProcessing;

             if (speaking) {
                 sessionButton.classList.remove('processing');
                 sessionButton.classList.add('speaking', 'active-session');
                 sessionButton.innerHTML = `<i class="fas fa-volume-up mr-2"></i> Speaking...`;
             } else {
                 sessionButton.classList.remove('speaking');
                 if (isProcessing) {
                     setButtonProcessing(true);
                 } else if (isSessionActive) {
                     sessionButton.innerHTML = '<i class="fas fa-stop mr-2"></i> End Session';
                     sessionButton.classList.add('active-session');
                     sessionButton.disabled = false;
                 } else {
                    sessionButton.innerHTML = '<i class="fas fa-play mr-2"></i> Start Session';
                    sessionButton.classList.remove('active-session');
                    sessionButton.disabled = false;
                 }
             }
        }
    </script>
</body>
</html>
